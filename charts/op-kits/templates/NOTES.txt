üéâ Operator Kits have been deployed successfully!

{{- $enabledCount := 0 }}
{{- if .Values.cloudnativepg.enabled }}{{ $enabledCount = add $enabledCount 1 }}{{- end }}
{{- if .Values.strimzi.enabled }}{{ $enabledCount = add $enabledCount 1 }}{{- end }}
{{- if .Values.valkey.enabled }}{{ $enabledCount = add $enabledCount 1 }}{{- end }}

{{- if gt $enabledCount 0 }}
üìã Enabled Components ({{ $enabledCount }}):
{{- if .Values.cloudnativepg.enabled }}
  ‚úÖ CloudNativePG - PostgreSQL cluster
{{- end }}
{{- if .Values.strimzi.enabled }}
  ‚úÖ Strimzi Kafka - Kafka cluster with KRaft mode
{{- end }}
{{- if .Values.valkey.enabled }}
  ‚úÖ Valkey - Redis-compatible in-memory data store
{{- end }}

üí° Required Operators (must be pre-installed):
{{- if .Values.cloudnativepg.enabled }}
  - CloudNativePG operator
{{- end }}
{{- if .Values.strimzi.enabled }}
  - Strimzi Kafka operator
{{- end }}
{{- if .Values.valkey.enabled }}
  - Valkey operator
{{- end }}

  See README.md for operator installation instructions if not already installed.

{{- else }}
‚ö†Ô∏è  Warning: No components are enabled!
   Enable at least one component (cloudnativepg, strimzi, or valkey) to deploy resources.
{{- end }}

{{- if .Values.cloudnativepg.enabled }}

üìä CloudNativePG PostgreSQL Cluster:
  - Cluster Name: {{ include "op-kits.cloudnativepg.clusterName" . }}
  - Namespace: {{ include "op-kits.namespace" . }}
  - Instances: {{ .Values.cloudnativepg.cluster.instances }}
  - Database: {{ .Values.cloudnativepg.cluster.bootstrap.initdb.database }}
  - Storage: {{ .Values.cloudnativepg.cluster.storage.size }}

üìã PostgreSQL Connection Information:

  Internal DNS Name (from within cluster):
    {{ include "op-kits.cloudnativepg.clusterName" . }}-rw.{{ include "op-kits.namespace" . }}.svc.cluster.local:5432

  Connection String Template:
    postgresql://[username]:[password]@{{ include "op-kits.cloudnativepg.clusterName" . }}-rw.{{ include "op-kits.namespace" . }}.svc.cluster.local:5432/{{ .Values.cloudnativepg.cluster.bootstrap.initdb.database }}

  Environment Variables for Applications (Superuser - can create databases):
    POSTGRES_HOST={{ include "op-kits.cloudnativepg.clusterName" . }}-rw.{{ include "op-kits.namespace" . }}.svc.cluster.local
    POSTGRES_PORT=5432
    POSTGRES_DATABASE={{ .Values.cloudnativepg.cluster.bootstrap.initdb.database }}
    POSTGRES_USER=[from secret: {{ include "op-kits.cloudnativepg.clusterName" . }}-superuser]
    POSTGRES_PASSWORD=[from secret: {{ include "op-kits.cloudnativepg.clusterName" . }}-superuser]

  Get superuser credentials:
    kubectl get secret -n {{ include "op-kits.namespace" . }} {{ include "op-kits.cloudnativepg.clusterName" . }}-superuser -o jsonpath='{.data.username}' | base64 -d
    kubectl get secret -n {{ include "op-kits.namespace" . }} {{ include "op-kits.cloudnativepg.clusterName" . }}-superuser -o jsonpath='{.data.password}' | base64 -d

  Alternative - Application user (limited privileges):
    kubectl get secret -n {{ include "op-kits.namespace" . }} {{ include "op-kits.cloudnativepg.clusterName" . }}-app -o jsonpath='{.data.username}' | base64 -d
    kubectl get secret -n {{ include "op-kits.namespace" . }} {{ include "op-kits.cloudnativepg.clusterName" . }}-app -o jsonpath='{.data.password}' | base64 -d
    
  ‚ö†Ô∏è  Note: The app user has limited privileges. To create databases, use the superuser 
      or grant CREATE DATABASE permission to the app user:
      GRANT CREATE ON DATABASE {{ .Values.cloudnativepg.cluster.bootstrap.initdb.database }} TO {{ .Values.cloudnativepg.cluster.bootstrap.initdb.owner }};

  For local development (port-forward):
    kubectl port-forward -n {{ include "op-kits.namespace" . }} svc/{{ include "op-kits.cloudnativepg.clusterName" . }}-rw 5432:5432
    # Then use: postgresql://[username]:[password]@localhost:5432/{{ .Values.cloudnativepg.cluster.bootstrap.initdb.database }}

{{- end }}

{{- if .Values.strimzi.enabled }}

üöÄ Strimzi Kafka Cluster:
  - Kafka Cluster: {{ include "op-kits.strimzi.kafkaName" . }}
  - Namespace: {{ include "op-kits.namespace" . }}
  {{- if .Values.strimzi.nodePools.controllers.enabled }}
  - Controllers: {{ .Values.strimzi.nodePools.controllers.replicas }}
  {{- end }}
  {{- if .Values.strimzi.nodePools.brokers.enabled }}
  - Brokers: {{ .Values.strimzi.nodePools.brokers.replicas }}
  {{- end }}

{{- $hasUsers := false }}
{{- range $name, $user := .Values.strimzi.users }}
{{- if and $user.enabled (ne $name "enabled") }}
{{- $hasUsers = true }}
{{- end }}
{{- end }}
{{- if $hasUsers }}
üë§ Kafka Users:
{{- range $name, $user := .Values.strimzi.users }}
{{- if and $user.enabled (ne $name "enabled") }}
  - {{ include "op-kits.strimzi.kafkaUserName" (dict "user" $user "root" $) }}
{{- end }}
{{- end }}

üìã Kafka Connection Information:

{{- if .Values.strimzi.kafka.listeners }}
  Internal Bootstrap Servers (from within cluster):
{{- range $listener := .Values.strimzi.kafka.listeners }}
    Listener "{{ $listener.name }}" ({{ $listener.type }}{{- if $listener.tls }}, TLS{{- end }}):
      {{ include "op-kits.strimzi.kafkaName" $ }}-kafka-bootstrap.{{ include "op-kits.namespace" $ }}.svc.cluster.local:{{ $listener.port }}
{{- end }}
{{- else }}
  Internal Bootstrap Servers (from within cluster):
    {{ include "op-kits.strimzi.kafkaName" . }}-kafka-bootstrap.{{ include "op-kits.namespace" . }}.svc.cluster.local:9092
{{- end }}

{{- if and .Values.strimzi.kafka.externalListener .Values.strimzi.kafka.externalListener.enabled }}

  üåê External Access Enabled:
    Listener: {{ .Values.strimzi.kafka.externalListener.listener.name }} ({{ .Values.strimzi.kafka.externalListener.listener.type }}{{- if .Values.strimzi.kafka.externalListener.listener.tls }}, TLS{{- end }})
    Port: {{ .Values.strimzi.kafka.externalListener.listener.port }}
    
    Get LoadBalancer address:
      kubectl get service {{ include "op-kits.strimzi.kafkaName" . }}-kafka-{{ .Values.strimzi.kafka.externalListener.listener.name }}-bootstrap -n {{ include "op-kits.namespace" . }}
    
    Bootstrap Server (external):
      <LOADBALANCER-ADDRESS>:{{ .Values.strimzi.kafka.externalListener.listener.port }}
{{- if .Values.strimzi.kafka.externalListener.listener.tls }}
    
    TLS Certificate (required for TLS connections):
      kubectl get secret {{ include "op-kits.strimzi.kafkaName" . }}-cluster-ca-cert \
        -n {{ include "op-kits.namespace" . }} \
        -o jsonpath='{.data.ca\.crt}' | base64 -d > ca.crt
{{- end }}
{{- end }}

  Environment Variables for Applications:
{{- if .Values.strimzi.kafka.listeners }}
{{- range $listener := .Values.strimzi.kafka.listeners }}
    # For listener "{{ $listener.name }}":
    KAFKA_BROKER_ADDRESS={{ include "op-kits.strimzi.kafkaName" $ }}-kafka-bootstrap.{{ include "op-kits.namespace" $ }}.svc.cluster.local:{{ $listener.port }}
{{- if $listener.tls }}
    KAFKA_SECURITY_PROTOCOL=SASL_SSL
{{- else }}
    KAFKA_SECURITY_PROTOCOL=SASL_PLAINTEXT
{{- end }}
{{- if $listener.authentication }}
    KAFKA_SASL_MECHANISM={{ $listener.authentication.type }}
{{- else }}
    KAFKA_SASL_MECHANISM=PLAIN
{{- end }}
{{- range $name, $user := $.Values.strimzi.users }}
{{- if and $user.enabled (ne $name "enabled") }}
    KAFKA_SASL_USERNAME={{ include "op-kits.strimzi.kafkaUserName" (dict "user" $user "root" $) }}
    {{- if and $user.authentication $user.authentication.password }}
    KAFKA_SASL_PASSWORD=[from secret: {{ $user.authentication.password.secretName }} key {{ $user.authentication.password.secretKey }}]
    {{- else }}
    KAFKA_SASL_PASSWORD=[from secret: {{ include "op-kits.strimzi.kafkaUserName" (dict "user" $user "root" $) }} key password]
    {{- end }}
{{- break }}
{{- end }}
{{- end }}
{{- end }}
{{- else }}
    KAFKA_BROKER_ADDRESS={{ include "op-kits.strimzi.kafkaName" . }}-kafka-bootstrap.{{ include "op-kits.namespace" . }}.svc.cluster.local:9092
    KAFKA_SASL_MECHANISM=SCRAM-SHA-512
{{- range $name, $user := .Values.strimzi.users }}
{{- if and $user.enabled (ne $name "enabled") }}
    KAFKA_SASL_USERNAME={{ include "op-kits.strimzi.kafkaUserName" (dict "user" $user "root" $) }}
    {{- if and $user.authentication $user.authentication.password }}
    KAFKA_SASL_PASSWORD=[from secret: {{ $user.authentication.password.secretName }} key {{ $user.authentication.password.secretKey }}]
    {{- else }}
    KAFKA_SASL_PASSWORD=[from secret: {{ include "op-kits.strimzi.kafkaUserName" (dict "user" $user "root" $) }} key password]
    {{- end }}
{{- break }}
{{- end }}
{{- end }}
{{- end }}

  Get Kafka credentials:
{{- range $name, $user := .Values.strimzi.users }}
{{- if and $user.enabled (ne $name "enabled") }}
    {{- if and $user.authentication $user.authentication.password }}
    kubectl get secret -n {{ include "op-kits.namespace" $ }} {{ $user.authentication.password.secretName }} -o jsonpath='{.data.{{ $user.authentication.password.secretKey }}}' | base64 -d
    {{- else }}
    kubectl get secret -n {{ include "op-kits.namespace" $ }} {{ include "op-kits.strimzi.kafkaUserName" (dict "user" $user "root" $) }} -o jsonpath='{.data.password}' | base64 -d
    {{- end }}
{{- break }}
{{- end }}
{{- end }}

  For local development (port-forward):
{{- if .Values.strimzi.kafka.listeners }}
{{- range $listener := .Values.strimzi.kafka.listeners }}
    kubectl port-forward -n {{ include "op-kits.namespace" $ }} svc/{{ include "op-kits.strimzi.kafkaName" $ }}-kafka-bootstrap {{ $listener.port }}:{{ $listener.port }}
    # Then use: localhost:{{ $listener.port }} with appropriate credentials
{{- end }}
{{- else }}
    kubectl port-forward -n {{ include "op-kits.namespace" . }} svc/{{ include "op-kits.strimzi.kafkaName" . }}-kafka-bootstrap 9092:9092
    # Then use: localhost:9092 with SASL credentials
{{- end }}

{{- end }}

{{- end }}

{{- if .Values.valkey.enabled }}

üóÑÔ∏è Valkey Cluster:
  - Cluster Name: {{ include "op-kits.valkey.clusterName" . }}
  - Namespace: {{ include "op-kits.namespace" . }}
  - Nodes: {{ .Values.valkey.cluster.nodes }}
  - Replicas per node: {{ .Values.valkey.cluster.replicas }}
  - Storage: {{ .Values.valkey.cluster.storage.spec.resources.requests.storage }}

üìã Valkey Connection Information:

  Internal DNS Name (from within cluster):
    {{ include "op-kits.valkey.clusterName" . }}.{{ include "op-kits.namespace" . }}.svc.cluster.local:6379

  Connection String Template:
    redis://{{ include "op-kits.valkey.clusterName" . }}.{{ include "op-kits.namespace" . }}.svc.cluster.local:6379

  Environment Variables for Applications:
    VALKEY_HOST={{ include "op-kits.valkey.clusterName" . }}.{{ include "op-kits.namespace" . }}.svc.cluster.local
    VALKEY_PORT=6379
    VALKEY_PASSWORD=[from secret: {{ .Values.valkey.cluster.servicePassword.name }}]

  Get Valkey password:
    kubectl get secret -n {{ include "op-kits.namespace" . }} {{ .Values.valkey.cluster.servicePassword.name }} -o jsonpath='{.data.{{ .Values.valkey.cluster.servicePassword.key }}}' | base64 -d

  For local development (port-forward):
    kubectl port-forward -n {{ include "op-kits.namespace" . }} svc/{{ include "op-kits.valkey.clusterName" . }} 6379:6379
    # Then use: redis://localhost:6379 with password

{{- end }}

üîç To monitor the deployment status:
  kubectl get all -n {{ include "op-kits.namespace" . }} -l app.kubernetes.io/instance={{ .Release.Name }}

üìö For more information:
  - CloudNativePG: https://cloudnative-pg.io/
  - Strimzi Kafka: https://strimzi.io/
  - Valkey: https://valkey.io/
